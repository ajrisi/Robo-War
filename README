Project:
	Robo-Wars
Team Members:
     Adam Risi
     Jon Potter

Project Description/Checkpoint 2:
	Overview:

		In project Robo-War, we will be using genetic
		algorithms to generate small programs that simulated
		robots will execute. The whole of the population will
		be executing at the same time, allowing the robots to
		"war" against eachother. When the number of remaining
		robots in the population reaches a given amount, new
		robots will be generated using crossover and
		mutatation methods. This "live" approach to a fitness
		function means that as the program runs, we will get
		to see the actual evolution of the robots from
		"brainless" drones, to something that should be a
		considerably stong warrior.

	Instance:
		
		The parameters of the problem are mostly the
		description of what the robots can "do" (motion,
		wepons, etc.) and the environment that they will be
		doing it in. The robots tentative abilities will be to
		turn, move forward or reverse, aim, and fire. As the
		programs development continues, the robots will be
		given more specific senses, like the ability to find
		groupings of other robots, etc. The environment will
		be a NxN space, with (presumably) a couple of
		obstacles.

	Solution:

		As a system with no perfect solution, the solution
		space is infinitely large. The program has the ability
		ot keep running as long as the user wants, and the
		ability to generate more and more complex
		warriors. The system will be run for as long as
		possible once development has reached stability. In
		code, each robot will have a "solution," - its
		internal program.

	Output:

		The output of this GA will be the source code for the
		different warring robots, and how well that given
		source code has done over time. How many battles the
		robot has survived, how many robots it has killed,
		etc. will all be used to judge the functionality of
		the robot.

Phenotype and Genotype Definition and Translation/Checkpoint 3:
	Work Summary:

		For this checkpoint, we have written the code to
		represent the robots genotype, and the robot
		phenotype. We have also written the fitness function
		(the simulator). There is still a significant amount
		of work that needs to be done on the simulatior;
		however, it does currently function.

	Genotype:
	  
		In this project, a robots instructions are defined as a
		finite set of program operation codes. These codes
		include things like "forward", "reverse", "rotate",
		etc. All robots are going to have the same length
		program, comprised of the same instructions.

		DATA STRUCTURE: We are using a simple ordered list to
		store the robots operation codes.

		GENETIC MAPPING: Genetic mapping is essentially the
		the simple execution of the ordered instruction codes.

		GENETIC REPAIR: All instruction codes are valid at any
		time. To prevent robots from roaming off the edge of
		the world, they will roll from one side to the
		opposite.

		BEST INDIVIDUAL AFTER ALL RUNS: The simulation starts
		with 2 individuals, and they are inherently the best,
		as they never die. As soon as the simulator is
		finished, they will be able to kill eachother, and the
		genetic algorithm will be able to start producting
		offspring.

		GRAPH GENERATED BY CODE: Graph is currently infinitely
		linear (y=x), because the simulator does not yet
		implement "fire." This means that the greatest fitness
		at any time slice is mearly the current time slice
		number (because no robots die, or kill any other
		robots).

	Phenotype:

		A robot will be graded based on its performance in a
		simulated battle. The phenotype for a given robot are
		its statistics while battling. So far, this includes
		the number of kills, and the number of time slices the
		robot has managed to stay alive. 

	Genotype/Phenotype Translation:
	
		In this project, the translation function is actually
		a complex, live, robot-battle simulation. As the
		robots battle, their statistics change, and so does
		their fitness (the sum of the kills and time
		alive). When a robot dies, a new robot is generated
		(from the living population) to take the place of the
		lost robot. The simulation itself executes each robots
		instructions, and calculates kills and life times.

	Building:
		
		This program does not need to be built - simply run
		robo-war.py and the simulator will begin. While the
		fitness for a given robot is being calculated, we are
		working on a way to display it.
